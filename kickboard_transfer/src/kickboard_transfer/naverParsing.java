package kickboard_transfer;
import java.util.Map;
import java.util.*;
import java.io.*;
import java.net.URL;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import org.json.simple.*;
import org.json.simple.parser.JSONParser;

public class naverParsing {
    private static Object jsonData(Point startp, Point endp) {
    	Object json = null;
        // Generated by curl-to-java: https://fivesmallq.github.io/curl-to-java

        // starting point
        double startX = startp.x;
        double startY = startp.y;
        double destX = endp.x;
        double destY = endp.y;

        String basicApi="https://naveropenapi.apigw.ntruss.com/map-direction/v1/driving?start=";
        String destDefault="&goal=";
        String optionDefault="&option=traavoidcaronly";

        String uriStr = String.format("%s%f,%f%s%f,%f%s",
            basicApi,
            startX,
            startY,
            destDefault,
            destX,
            destY,
            optionDefault
            );

        try {
            URL url = new URL(uriStr);
            HttpURLConnection http = (HttpURLConnection)url.openConnection();
            http.setRequestProperty("X-Ncp-Apigw-Api-Key-Id", "j4suedvzn7");
            http.setRequestProperty("X-Ncp-Apigw-Api-Key", "zDGIKKT4QG1uiAoWdLuRAQ6Z7PlMrIcdPywms29M");
            // 연결 타임아웃 설정 
            http.setConnectTimeout(3000); // 3초 
            // 읽기 타임아웃 설정 
            http.setReadTimeout(3000); // 3초 
            
//            // 요청 방식 구하기
//            System.out.println("getRequestMethod():" + http.getRequestMethod());
//            // 응답 콘텐츠 유형 구하기
//            System.out.println("getContentType():" + http.getContentType());
//            // 응답 코드 구하기
//            System.out.println("getResponseCode():"    + http.getResponseCode());
//            // 응답 메시지 구하기
//            System.out.println("getResponseMessage():" + http.getResponseMessage());

            // 응답 헤더의 정보를 모두 출력
//            for (Map.Entry<String, List<String>> header : http.getHeaderFields().entrySet()) {
//                for (String value : header.getValue()) {
//                    System.out.println(header.getKey() + " : " + value);
//                }
//            }
            
            // 응답 내용(BODY) 구하기        
            InputStream in = http.getInputStream();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            byte[] buf = new byte[1024 * 8];
            int length = 0;
            while ((length = in.read(buf)) != -1) {
                out.write(buf, 0, length);
            }
            String result = new String(out.toByteArray(), "UTF-8");
            in.close();
            out.close();
//            System.out.println(result);

            try {
            	JSONParser parser = new JSONParser();
                json = parser.parse(result);
            }catch(Exception e) {}

            http.disconnect();
            return json;
        }
        catch (MalformedURLException e) {}
        catch (IOException e) {}
        return json;
    }
    
    public static String jsonToText(Point startp, Point endp, int pathNumber) {
    	BufferedWriter wr;
//    	ArrayList<Arrays> x_coor, y_coor;
    	JSONObject json = (JSONObject) jsonData(startp, endp);
    	
    	try {
    		//get coordinate data from the given JSON data
    		JSONObject trans = (JSONObject) json.get("route");
    		JSONArray inData = (JSONArray) trans.get("traavoidcaronly");
    		JSONObject innerData = (JSONObject) inData.get(0);
    		
    		ArrayList<Object> coordinates = (ArrayList<Object>) innerData.get("path");
//    		System.out.print(coordinates + "\n");
    		
    		String pathTXT = "./path" + Integer.toString(pathNumber) + ".txt";
    		
    		wr = new BufferedWriter(new FileWriter(pathTXT));
    		wr.write(coordinates.size() + "\n");
    		for(int i = 0; i < coordinates.size(); i++) {
    			String line = coordinates.get(i).toString();
    			int length = line.length();
    			int comma = line.indexOf(",");
    			wr.write(line.substring(1, comma) + " " + line.substring(comma + 1, length - 1) + "\n");
    		}
    		
    		wr.close();
     	}catch(Exception e) {}
    	
    	return "./path.txt";
    }
}